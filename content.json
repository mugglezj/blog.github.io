[{"title":"个人兴趣写的demo","date":"2018-12-12T14:14:00.000Z","path":"2018/12/12/some-code/","text":"1.使用webrtc创建的视频聊天应用2.[浏览器|node端五子棋模型训练]3.仿bilibili视频人像弹幕遮罩 资源载的有点慢，4.cocos瞎写的demo","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"从vue源码看测试集成","date":"2017-12-21T15:32:00.000Z","path":"2017/12/21/vue-test/","text":"从测试命令开始：入口测试指令npm run test;在package.json 当中；1\"test\": \"npm run lint &amp;&amp; flow check &amp;&amp; npm run test:types &amp;&amp; npm run test:cover &amp;&amp; npm run test:e2e -- --env phantomjs &amp;&amp; npm run test:ssr &amp;&amp; npm run test:weex\", 前三条是语法检测，按照各自的代码格式或者语法配置说明配置好之后就能顺利跑起来，并且带自动纠正功能。 npm run test:cover1\"test:cover\": \"karma start test/unit/karma.cover.config.js\" 单元测试部分，能够生成测试覆盖率报告；首先看入口测试配置：karma.cover.config.js；第一行导入了所有测试都引入的基本配置文件karma.base.config.js;其中定义了单元测试的基本框架以及入口文件等； 结合两份配置分析。 首先是一些基本概念： Karma是一个基于Node.js的JavaScript测试执行过程管理工具（Test Runner）。 Jasmine是单元测试框架，本单将介绍用Karma让Jasmine测试自动化完成。 istanbul是一个单元测试代码覆盖率检查工具，可以很直观地告诉我们，单元测试对代码的控制程度。 使用karma框架 karma介绍; jasmine语法介绍; karma配置中定义了： 使用Jasmine单元测试框架； karma-webpack 的基本配置（对于模块化的源代码，需要使用webpack进行预处理）； 待测试的文件和测试文件的总入口：’index.js’（在index.js中通过require.content来动态引入需要测试的文件，减少源码更改之后测试配置改动的需求）； 定义js文件需要使用的预处理器：[‘webpack’,’sourcemap’]; 使用phantomjs无头浏览器，不实例化页面，加快测试速度； 报告类型选用[‘mocha’, ‘coverage’];其中 karma-mocha-reporter用来更改报告样式;coverage用来生成测试覆盖率报告； coverageReporter配置测试覆盖率报告的风格，已经报告生成目录； 注意的点:一般我们在配置测试覆盖率的时候写法是：123preprocessors: &#123; './src/*.js': ['coverage']&#125;, 使用coverage预处理把src目录下的所有js文件全都加入覆盖率统计当中；但是使用karma-coverage检测Webpack打包后的代码，会出现覆盖率出错的情况,因为一般代码覆盖率的检测是需要统计被测试代码中需要测试的量，比如函数、行数等信息，然而打包后的代码因为被混入了很多别的代码，或者是变量被私有化了，这些统计就会出问题。 在这里作者使用了babel-plugin-istanbul插件在代码打包之前进行统计;自此，单元测试配置基本解决；剩下的就是测试代码的编写；遵循jasmine使用规范；使用describe加回调函数的套件；一步步完成对源代码的测试用例编写；完善覆盖率 npm run test:e2e端对端测试","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"mockjs","date":"2017-03-02T07:25:00.000Z","path":"2017/03/02/mockjs/","text":"Mock.js实现的功能 基于 数据模板 生成数据 基于 HTML模板 生成数据 拦截并模拟 Ajax请求 让前端独立于后端进行开发[mockjs 文档]https://github.com/nuysoft/Mock/wiki 现在前端获取数据有2种方式： 使用proxy代理，直接获取接口数据 使用mockjs，获取随机数据 引入项目关于mockjs的用法直接看文档有详细介绍，这里写的是如何引入项目，使开发使用mockjs，线上环境走正常流程有以下三种实现方式： 1.在webpack配置中加上环境变量,入口文件中根据是否生产环境来判断是否使用mockjs 1234567891011121314//webpack.dev.confignew webpack.DefinePlugin(&#123; 'process.env': config.dev.env &#125;);//entry.jsif(process.env.NODE_ENV == 'production')&#123; const mock = require('mock.js')&#125;//mock.jsimport Mock from 'mockjs'Mock.mock( rurl, template ) 2.在webpack.dev.conf.js配置文件中把写好的mock.js文件单独打包一份，在页面中引入，实现开发环境下引入脚本。 123456789var config = &#123; entry: &#123; app: '入口', vendor: ['mock.js'] //第三方库 &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin('vendor', 'vendor.bundle.js')//这是妮第三方库打包生成的文件 ]&#125; 3.这个方法其实没有真正使用到mockjs，只是在发送请求的时候代理到自己的express中，然后返回需要的数据，具体用法如下： 12345678910111213141516171819202122232425//dev-server.jsvar app = new express()var mockDir = path.resolve(__dirname, '../mock');(function setMock(mockDir) &#123; fs.readdirSync(mockDir).forEach(function (file) &#123; var filePath = path.resolve(mockDir, file); var mock; if (fs.statSync(filePath).isDirectory()) &#123; setMock(filePath); &#125; else &#123; mock = require(filePath); app.use(mock.api, argv.proxy ? proxyMiddleware(&#123;target: 'http://' + argv.proxy&#125;) : mock.response); &#125; &#125;);&#125;)(mockDir);// ~./mock/hello.jsmodule.exports = &#123; api: '/api/hello', response: function (req, res) &#123; res.send('mock-data'); &#125;&#125; 我用的是第二种写法，能够满足各种需求。个人觉得mockjs不仅可以用在拦截ajax返回随机数据这方面，还可以用来做很好的单元测试工具。","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"前端工程单元测试和功能测试","date":"2017-02-17T13:25:00.000Z","path":"2017/02/17/js-unit-test/","text":"keyword: mocha, nightmare, nightwatch Web 应用越来越复杂，意味着更可能出错。测试是提高代码质量、降低错误的最好方法之一。 测试可以确保得到预期结果。 加快开发速度。 方便维护。 提供用法的文档。 对于长期维护的项目，测试可以减少投入时间，减轻维护难度。 测试的类型 单元测试（unit testing） 功能测试（feature testing） 集成测试（integration testing） 端对端测试 (End-to-End testing） 以测试为导向的开发模式 TDD：测试驱动的开发（Test-Driven Development） BDD：行为驱动的开发（Behavior-Driven Development）它们都要求先写测试，再写代码。 以上来自阮一峰 mocha Mocha是一个测试框架，在浏览器和node环境中都能使用。除了Mocha，类似的测试框架还有Jasmine、Karma、Tape等 Mocha最好搭配一个断言库来使用，我用的是chai 动手12npm install mocha --globalnpm install mocha,chai --save-dev 现有一个待测试的函数：12345//a.jsfunction a() &#123; return 1&#125;module.exports = test; 编写测试脚本：通常，测试脚本与所要测试的源码脚本同名，但是后缀名为.test.js（表示测试）或者.spec.js（表示规格）。123456789101112131415161718//a.test.jsvar a = require('a.js'),expert = require('chai').expert,should = require('chai').should(),assert = require('chai').assert;describe('a函数的测试', function() &#123; it('a函数返回1', function() &#123; expect(a()).to.be.equal(1); &#125;); it('a函数返回1', function() &#123; a().should.equal(1); &#125;); it('a函数返回1',function() &#123; assert.equal(a(),1) &#125;) &#125;); 上面这段代码，就是测试脚本，它可以独立执行。测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块。describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称，第二个参数是一个实际执行的函数。it块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称，第二个参数是一个实际执行的函数。 expect(add(1, 1)).to.be.equal(2);是一句断言。所谓”断言”，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。上面这句断言的意思是，调用add(1, 1)，结果应该等于2。所有的测试用例（it块）都应该含有一句或多句的断言。它是编写测试用例的关键。断言功能由断言库来实现，Mocha本身不带断言库，所以必须先引入断言库。 如果断言不成立，就会抛出一个错误。事实上，只要不抛出错误，测试用例就算通过。上面代码用到chai的export、should和assert三种断言风格，读者可依据自己喜好随意选择。 mocha 命令行参数 –help或-h参数，用来查看Mocha的所有命令行参数。 –reporter，-R 参数用来指定测试报告的格式，默认是spec格式。 –reporters参数可以显示所有内置的报告格式。 –watch，-w 参数用来监视指定的测试脚本。只要测试脚本有变化，就会自动运行Mocha。 –bail，-b 参数指定只要有一个测试用例没有通过，就停止执行后面的测试用例。这对持续集成很有用。 –grep，-g 参数用于搜索测试用例的名称（即it块的第一个参数），然后只执行匹配的测试用例。 –invert，-i 参数表示只运行不符合条件的测试脚本，必须与–grep参数配合使用。ES6如果测试脚本是用ES6写的，那么运行测试之前，需要先用Babel转码。1npm install babel-core babel-preset-es2015 --save-dev 然后，在项目目录下面，新建一个.babelrc配置文件。123&#123; \"presets\": [ \"es2015\" ]&#125; 最后，使用–compilers参数指定测试脚本的转码器。1../node_modules/mocha/bin/mocha --compilers js:babel-core/register 上面代码中，–compilers参数后面紧跟一个用冒号分隔的字符串，冒号左边是文件的后缀名，右边是用来处理这一类文件的模块名。上面代码表示，运行测试之前，先用babel-core/register模块，处理一下.js文件。由于这里的转码器安装在项目内，所以要使用项目内安装的Mocha；如果转码器安装在全局，就可以使用全局的Mocha。注意，Babel默认不会对Iterator、Generator、Promise、Map、Set等全局对象，以及一些全局对象的方法（比如Object.assign）转码。如果你想要对这些对象转码，就要安装babel-polyfill。 1$ npm install babel-polyfill --save 然后，在你的脚本头部加上一行。1import 'babel-polyfill' 测试用例的钩子Mocha在describe块之中，提供测试用例的四个钩子：before()、after()、beforeEach()和afterEach()。它们会在指定时间执行。1234567891011121314151617181920describe('hooks', function() &#123; before(function() &#123; // 在本区块的所有测试用例之前执行 &#125;); after(function() &#123; // 在本区块的所有测试用例之后执行 &#125;); beforeEach(function() &#123; // 在本区块的每个测试用例之前执行 &#125;); afterEach(function() &#123; // 在本区块的每个测试用例之后执行 &#125;); // test cases&#125;); 浏览器测试除了在命令行运行，Mocha还可以在浏览器运行。首先，使用mocha init命令在指定目录生成初始化文件。然后，把需要测试的文件如add.js，以及断言库chai.js，加入index.html。123456789&lt;script&gt; mocha.setup('bdd');&lt;/script&gt;&lt;script src=\"add.js\"&gt;&lt;/script&gt;&lt;script src=\"http://chaijs.com/chai.js\"&gt;&lt;/script&gt;&lt;script src=\"tests.js\"&gt;&lt;/script&gt;&lt;script&gt; mocha.run();&lt;/script&gt; 最后，在tests.js里面写入测试脚本。打开index.html就能看到测试结果。 生成规格文件1mocha --recursive -R markdown &gt; spec.md 上面命令根据test目录的所有测试脚本，生成一个规格文件spec.md。-R markdown参数指定规格报告是markdown格式。如果想生成HTML格式的报告spec.html，使用下面的命令。1$ mocha --recursive -R doc &gt; spec.html Nightmare nightmare是一个基于phantomjs的测试框架一个基于phantomjs之上为测试应用封装的一套high level API。其API以goto, refresh, click, type…等简单的常用e2e测试动作封装，使得其语义清晰，简洁。 动手123456# Linux &amp; Mac$ env ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/ npm install# Windows$ set ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/$ npm install 注意，Nightmare 会先安装 Electron，而 Electron 的安装需要下载境外的包，有时会连不上，导致安装失败。所以，这里先设置了环境变量，指定使用国内的 Electron 源，然后才执行安装命令。 12var Nightmare = require('nightmare');var nightmare = Nightmare(&#123; show: true &#125;); 上面代码表示新建一个 Nightmare 实例，并且运行功能中，自动打开浏览器窗口。 12345678910nightmare .goto('https://www.taobao.com/') .type('#q', '电视机') .click('form[action*=\"/search\"] [type=submit]') .wait('#spulist-grid') .evaluate(function () &#123; return document.querySelector('#spulist-grid .grid-item .info-cont') .textContent.trim(); &#125;) .end() 上面代码表示，打开淘宝首页，在搜索框键入电视机，点击”搜索“按钮，等待#spulist-grid元素出现，在页面内注入（evaluate）代码，将执行结果返回。 123456.then(function (result) &#123; console.log(result);&#125;).catch(function (error) &#123; console.error('Search failed:', error);&#125;); Nightmare 会返回一个 Promise 对象，then方法指定操作成功的回调函数，catch方法指定操作失败的回调函数。 结合mocha12345678910111213141516171819202122232425262728293031323334353637383940414243var Nightmare = require('nightmare');var expect = require('chai').expect;var fork = require('child_process').fork;describe('test index.html', function() &#123; var child; before(function (done) &#123; child = fork('./server.js'); child.on('message', function (msg) &#123; if (msg === 'listening') &#123; done(); &#125; &#125;); &#125;); after(function () &#123; child.kill(); &#125;); it('点击后标题改变', function (done) &#123; var nightmare = Nightmare(&#123; show: true &#125;); nightmare .goto('http://127.0.0.1:8080/index.html') .click('h1') .wait(1000) .evaluate(function () &#123; return document.querySelector('h1').textContent; &#125;) .end() .then(function(text) &#123; expect(text).to.equal('Hello Clicked'); done(); &#125;) &#125;);&#125;);//子进程脚本server.jsvar httpServer = require('http-server');var server = httpServer.createServer();server.listen(8080);process.send('listening'); nightwatchnightwatch与nightmare相似，都用于做端对端（e2e）测试。因为在vue-cli中使用的是nightwatch，所以一并介绍。 Nightwatch是一套新近问世的基于Node.js的验收测试框架，使用Selenium WebDriver API以将Web应用测试自动化。它提供了简单的语法，支持使用JavaScript和CSS选择器，来编写运行在Selenium服务器上的端到端测试。 目前，Selenium是JavaScript的世界里验收测试方面最流行的工具之一，类似的还有PhantomJS。二者都有其独到的方法：Selenium使用其WebDriver API，而PhantomJS使用无界面的WebKit浏览器。它们都是非常成熟的工具，都具有强大的社区支持。它们与Nightwatch之间最大的不同，主要是在于语法的简易度以及对持续集成的支持。与Nightwatch相比，Selenium和PhantomJS都拥有更加冗长的语法，这会让编码变得更庞大，而且不支持从命令行中进行开箱即用的持续集成（JUnit XML或其他标准输出）。 不同于行为驱动测试（BDD）和单元测试独立运行并使用模拟/存根，端到端测试将试着尽可能从用户的视角，对真实系统的访问行为进行仿真。对Web应用来说，这意味着需要打开浏览器、加载页面、运行JavaScript，以及进行与DOM交互等操作。 动手1$ npm install [-g] nightwatch 配置文件：nighewatch.conf.js 或nightwatch.json1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; \"src_folders\" : [\"tests\"], //测试文件存放地址 \"output_folder\" : \"reports\", //生成JUnit XML 测试报告保存地址 \"custom_commands_path\" : \"\", \"custom_assertions_path\" : \"\", \"page_objects_path\" : \"\", \"globals_path\" : \"\", //外部全局扩展地址，能在test_settings中重新定义覆盖 \"selenium\" : &#123; //selenium 配置 \"start_process\" : false, \"server_path\" : \"\", \"log_path\" : \"\", \"port\" : 4444, \"cli_args\" : &#123; \"webdriver.chrome.driver\" : \"\", \"webdriver.gecko.driver\" : \"\", \"webdriver.edge.driver\" : \"\" &#125; &#125;, \"test_settings\" : &#123; //所有测试选项 \"default\" : &#123; \"launch_url\" : \"http://localhost\", \"selenium_port\" : 4444, \"selenium_host\" : \"localhost\", \"silent\": true, \"globals\" : &#123; \"myGlobalVar\" : \"some value\", \"otherGlobal\" : \"some other value\" &#125; \"screenshots\" : &#123; \"enabled\" : false, \"path\" : \"\" &#125;, \"desiredCapabilities\": &#123; //传给selenium的浏览器驱动 \"browserName\": \"firefox\", \"marionette\": true &#125; &#125;, \"chrome\" : &#123; \"desiredCapabilities\": &#123; \"browserName\": \"chrome\" &#125; &#125;, \"edge\" : &#123; \"desiredCapabilities\": &#123; \"browserName\": \"MicrosoftEdge\" &#125; &#125; &#125;&#125; 其余配置项： live_output:boolean————Whether or not to buffer the output in case of parallel running. See below for details. disable_colors:boolean————Controls whether or not to disable coloring of the cli output globally. parallel_process_delay:integer————Specifies the delay(in milliseconds) between starting the child processes when running in parallel mode. test_workers:boolean|object————Whether or not to run individual test files in parallel. If set to true, runs the tests in parallel and determines the number of workers automatically.If set to an object, can specify specify the number of workers as “auto” or a number.Example: &quot;test_workers&quot; : {&quot;enabled&quot; : true, &quot;workers&quot; : &quot;auto&quot;} test_runner：string|object ————Specifies which test runner to use when running the tests. Values can be either default (built in nightwatch runner) or mocha.Example: &quot;test_runner&quot; : {&quot;type&quot; : &quot;mocha&quot;, &quot;options&quot; : {&quot;ui&quot; : &quot;tdd&quot;}} Selenium设置Nightwatch 能自动开启和停止Selenium进程，所以不用过多关注这一项。If you’d like to enable this, set start_process to true and specify the location of the jar file inside server_path.如果不想开启这项功能，设置start_process为true并且在server_path中指定selenium 的jar文件详细目录，例如： bin/selenium-server-standalone-2.43.0.jar 还有日志存放目录、监听端口、cli参数配置不多介绍 Test settings设置default为必须，其他都是从此继承而来1nightwatch --env chrome 即执行到chrome里的配置 1234567891011121314module.exports = &#123; 'Demo test' : function (browser) &#123; console.log(browser.globals); // &#123; // \"myGlobalVar\" : \"some value\", // \"otherGlobal\" : \"some other value\" // &#125; browser .url(browser.launchUrl) // ... .end(); &#125;&#125;; 以上是.test.js中的部分代码，用来说明配置关系。 还有其他详细配置，太长不看。 编写用例一个基本的测试文件如下：12345678910111213module.exports = &#123; &apos;Demo test Google&apos; : function (browser) &#123; browser .url(&apos;http://www.google.com&apos;) .waitForElementVisible(&apos;body&apos;, 1000) .setValue(&apos;input[type=text]&apos;, &apos;nightwatch&apos;) .waitForElementVisible(&apos;button[name=btnG]&apos;, 1000) .click(&apos;button[name=btnG]&apos;) .pause(1000) .assert.containsText(&apos;#main&apos;, &apos;Night Watch&apos;) .end(); &#125;&#125;; 调用.end()来关闭Selenium会话1234567891011121314151617module.exports = &#123; 'step one' : function (browser) &#123; browser .url('http://www.google.com') .waitForElementVisible('body', 1000) .setValue('input[type=text]', 'nightwatch') .waitForElementVisible('button[name=btnG]', 1000) &#125;, 'step two' : function (browser) &#123; browser .click('button[name=btnG]') .pause(1000) .assert.containsText('#main', 'Night Watch') .end(); &#125;&#125;; 多个步骤的test 1234567891011121314151617181920212223242526module.exports = &#123; before : function(browser) &#123; console.log('Setting up...'); &#125;, after : function(browser，done) &#123; setTimeout(function()&#123; done() &#125;,0) &#125;, 'Demo test Google' : function (client) &#123; client .url('http://google.no') .pause(1000); // expect element to be present in 1000ms client.expect.element('body').to.be.present.before(1000); // expect element &lt;#lst-ib&gt; to have css property 'display' client.expect.element('#lst-ib').to.have.css('display'); // expect element to have attribute 'class' which contains text 'vasq' client.expect.element('body').to.have.attribute('class').which.contains('vasq'); // expect element &lt;#lst-ib&gt; to be an input tag client.expect.element('#lst-ib').to.be.an('input'); // expect element &lt;#lst-ib&gt; to be visible client.expect.element('#lst-ib').to.be.visible; client.end(); &#125;&#125;; expect的原型是来自chai的expect接口同样拥有before[Each] and after[Each]钩子异步操作使用回调函数来完成执行。如上面的done() Api接口接口大致分为如下四类 expect 如 browser.expect.element(‘#main’).text.to.equal(‘The Night Watch’); assert 操作命令 如 client.click(“#main ul li a.first”); 浏览器驱动的协议 如： browser.url(‘http://localhost‘); 与mocha搭配使用首先在nightwatch.json文件中添加：1234&#123; ... \"test_runner\" : \"mocha\"&#125; 一个标准的与mocha搭配的测试文件应该如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var nightwatch = require('nightwatch');describe('Github', function() &#123; var client = nightwatch.initClient(&#123; silent : true &#125;); var browser = client.api(); this.timeout(99999999); before(function() &#123; browser.perform(function() &#123; console.log('beforeAll') &#125;); &#125;); beforeEach(function(done) &#123; browser.perform(function() &#123; console.log('beforeEach') &#125;); client.start(done); &#125;); it('Demo test GitHub', function (done) &#123; browser .url('https://github.com/nightwatchjs/nightwatch') .waitForElementVisible('body', 5000) .assert.title('nightwatchjs/nightwatch · GitHub') .waitForElementVisible('body', 1000) .assert.visible('.container .breadcrumb a span') .assert.containsText('.container .breadcrumb a span', 'nightwatch', 'Checking project title is set to nightwatch'); client.start(done); &#125;); afterEach(function() &#123; browser.perform(function() &#123; console.log('afterEach') &#125;); &#125;); after(function(done) &#123; browser.end(function() &#123; console.log('afterAll') &#125;); client.start(done); &#125;);&#125;); 单页面测试配置可以通过配置nightwatch.js中page_objects_path来实现 page_object.js：123456789101112131415161718192021//google.jsvar googleCommands = &#123; submit: function() &#123; this.api.pause(1000); return this.waitForElementVisible('@submitButton', 1000) .click('@submitButton') .waitForElementNotPresent('@submitButton'); &#125;&#125;;module.exports = &#123; commands: [googleCommands], elements: &#123; searchBar: &#123; selector: 'input[type=text]' &#125;, submitButton: &#123; selector: 'button[name=btnG]' &#125; &#125;&#125;; test.js就可以变为：123456789module.exports = &#123; 'Test': function (client) &#123; var google = client.page.google(); google.setValue('@searchBar', 'nightwatch') .submit(); client.end(); &#125;&#125;; 还可以定义elements和sections 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var sharedElements = &#123; mailLink: 'a[href*=\"mail.google.com\"]'&#125;;module.exports = &#123; elements: [ sharedElements, &#123; searchBar: 'input[type=text]' &#125; ], sections: &#123; menu: &#123; selector: '#gb', elements: &#123; mail: &#123; selector: 'a[href=\"mail\"]' &#125;, images: &#123; selector: 'a[href=\"imghp\"]' &#125; &#125;, sections: &#123; apps: &#123; selector: 'div.gb_pc', elements: &#123; myAccount: &#123; selector: '#gb192' &#125;, googlePlus: &#123; selector: '#gb119' &#125; &#125; &#125; &#125; &#125; &#125;&#125;//test.js中module.exports = &#123; 'Test': function (client) &#123; var google = client.page.google(); google.expect.section('@menu').to.be.visible; var menuSection = google.section.menu; var appSection = menuSection.section.apps; menuSection.click('@appSection'); appSection.expect.element('@myAccount').to.be.visible; appSection.expect.element('@googlePlus').to.be.visible; client.end(); &#125;&#125; 自此，终于可以结合vue代码写出一个完整的测试用例啦~~~ 话不多说，试着撸代码去了。 karmaKarma是一个测试任务管理工具，可以很容易和Jasmine、Mocha等市面上常用的测试框架打通，通过其插件可以快速集成到各种环境中。例如：本地环境、持续集成环境。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"浏览器内部工作原理","date":"2017-02-17T13:25:00.000Z","path":"2017/02/17/how-browsers-work/","text":"浏览器的高层结构浏览器的主要组件为： 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。 浏览器引擎 - 在用户界面和呈现引擎之间传送指令。 呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。 JavaScript 解释器。用于解析和执行 JavaScript 代码。 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 呈现引擎呈现引擎的作用嘛…当然就是“呈现”了，也就是在浏览器的屏幕上显示请求的内容。默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。有关详情，请参阅 webkit.org。 主流程呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。然后进行如下所示的基本流程： 图：呈现引擎的基本流程。呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。 呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。 呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。 需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。 原文：How Browsers Work: Behind the Scenes of Modern Web Browsers 不想搬了。","tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"vue.js的一次实践","date":"2017-02-10T13:25:00.000Z","path":"2017/02/10/vue-guide/","text":"keyword：nodejs，webpack，vue-cli，vue-router，vue-resource，vuex，vux 首先假装自己已经熟悉了nodejs和webpack的基本使用方法 安装 安装vue 1234npm install vue-cli -gvue init webpack projectnamecd projectnamenpm install 安装其他依赖 1npm install vue-router, vue-resource, vuex, vux, vux-loader, vuex-i18n --save 目录结构：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162project│ .babelrc│ .editorconfig│ .eslintignore│ .eslintrc.js│ .gitignore│ index.html│ package.json│ README.md│ ├─build│ build.js│ check-versions.js│ dev-client.js│ dev-server.js│ utils.js│ vue-loader.conf.js│ webpack.base.conf.js│ webpack.dev.conf.js│ webpack.prod.conf.js│ webpack.test.conf.js│ ├─config│ dev.env.js│ index.js│ prod.env.js│ test.env.js│ ├─src│ │ App.vue│ │ main.js│ │ │ ├─assets│ │ logo.png│ │ │ ├─components│ │ Hello.vue│ │ │ └─router│ index.js│ ├─static│ .gitkeep│ └─test ├─e2e │ │ nightwatch.conf.js │ │ runner.js │ │ │ ├─custom-assertions │ │ elementCount.js │ │ │ └─specs │ test.js │ └─unit │ .eslintrc │ index.js │ karma.conf.js │ └─specs Hello.spec.js 根据需求修改脚手架： 引入vux和vux-loader：vux2必须配合vux-loader使用, 在build/webpack.base.conf.js里参照如下代码进行配置： 12345678910111213const vuxLoader = require('vux-loader')module.exports = vuxLoader.merge(webpackConfig, &#123; options: &#123;&#125;, plugins: [ &#123; name: 'vux-ui' &#125;, &#123; name: 'less-theme', path: 'src/styles/theme.less' //vux自定义主题文件 &#125; ]&#125;) vux部分组件用到i18n函数，如toast,故引入vuex-i18n； 该插件通过$t()方法的使用易于访问本地化信息。 这个插件将会在当前定义的区域中寻找将给定的字符串作为key，并返回相应的翻译。如果没有找到字符串，它将返回。 在入口文件添加： 1234567891011121314import Vue from 'vue'import Vuex from 'vuex'import vuexI18n from 'vuex-i18n'Vue.use(Vuex)// const debug = process.env.NODE_ENV !== 'production'let store = new Vuex.Store(&#123; modules: &#123; i18n: vuexI18n.store, &#125;, // strict: debug,&#125;)Vue.use(vuexI18n.plugin, store)Vue.i18n.set('zh-CN')export default store 配置开发代理服务器： 修改config/index.js文件：12345678910&#123;proxyTable: &#123; '/api': &#123; target: 'http://localhost:9000', changeOrigin: true, pathRewrite: &#123; '^/api': '/api' &#125; &#125; &#125;&#125; 这样在请求 ‘/api/xxx’的时候会被代理到’localhost:9000/api/xxx’，用来解决本地node起的服务器取接口数据的跨域问题。 配置多入口： 项目需求多入口，分模块。 首先在build/utils.js 下添加： 12345678910var glob = require('glob');exports.getEntries = function (globPath) &#123; var entries = &#123;&#125; glob.sync(globPath).forEach(function (entry) &#123; var tmp = entry.split('/').splice(-3) var moduleName = tmp.slice(1, 2); entries[moduleName] = entry &#125;); return entries;&#125; 获取入口的函数 接着在build/webpack.dev.conf.js和build/webpack.prod.conf.js中先把new HtmlWebpackPlugin()删掉，然后添加： 12345678910111213141516var pages = utils.getEntries('./src/module/**/*.html')for(var page in pages) &#123; // 配置生成的html文件，定义路径等 var conf = &#123; filename: page + '.html', template: pages[page], //模板路径 inject: true, // excludeChunks 允许跳过某些chunks, 而chunks告诉插件要引用entry里面的哪几个入口 //即去除名字与html不一样的js; // 即去除名字与html不一样的js; excludeChunks: Object.keys(pages).filter(item =&gt; &#123; return (item != page) &#125;) &#125; // 需要生成几个html文件，就配置几个HtmlWebpackPlugin对象 module.exports.plugins.push(new HtmlWebpackPlugin(conf))&#125; 至此，脚手架就搭建完成 代码逻辑层 关于vue-router，应该抛开原先写后端的mvc模式，思维不能太僵化。个人的实践如下： 在router.js中 12345678910111213141516171819202122232425262728293031323334var routers = &#123; routes: [ &#123; path: '/', redirect: '/index/index' &#125;, &#123; path: '/tool', name: 'Tool', component: Tool &#125;, &#123; path: '/index', name: 'Index', component: IndexMain, children:[&#123; path:'index', component:Index, children:[&#123; path:'a', component:a &#125;] &#125;,&#123; path:'status/:id', component:Status &#125;,] &#125;, &#123; path: '/login', name: 'login', component: login &#125; ]&#125; 并且在App.vue中页面保持纯净： 12345&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 通过路由嵌套来一层层加载组件；如 index.vue 1234567&lt;template&gt; &lt;div&gt; &lt;top-header&gt;&lt;/top-header&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;bottom-menu&gt;&lt;/bottom-menu&gt; &lt;/div&gt;&lt;/template&gt; login.vue 123456789101112&lt;template&gt; &lt;div&gt; &lt;box gap=\"10px 10px\"&gt; &lt;group&gt; &lt;x-input placeholder=\"请输入账号\" required v-model=\"username\"&gt;&lt;/x-input&gt; &lt;x-input placeholder=\"请输入密码\" required v-model=\"password\"&gt;&lt;/x-input&gt; &lt;/group&gt; &lt;x-button :text=\"buttonText\" :disabled=\"buttonDisable\" @click.native=\"test\" type=\"primary\"&gt;&lt;/x-button&gt; &lt;/box&gt; &lt;toast :text=\"toastText\" v-model=\"toastShow\" type=\"cancel\"&gt;&lt;/toast&gt; &lt;/div&gt;&lt;/template&gt; 在/index的路由下，有头菜单和下方菜单tab组件，而/login下就是纯净的登录页面，增加了灵活性。 还是关于路由，路由实例化最好在main.js下执行而不是单独在router/index.js中。原因是实际项目有可能需要在路由中操作store，如router.beforeEach()中做跳转的动画，单独文件取不到store。 关于vuex： 每一个 Vuex 应用的核心就是 store（仓库）。”store” 基本上就是一个容器，它包含着你的应用中大部分的状态(state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交(commit) mutations。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 具体使用方法参见：vuex文档 自此，就可以愉快的开始编写业务代码了。勇敢的少年啊，快去创造奇迹。 关于单元测试我还不懂怎么用。断言库和end2end是什么我根本就不知道。等学完mocha或者karma再补充更新。 未完待续。","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"vue-cli的webpack模板项目配置文件分析(转)","date":"2017-02-10T13:25:00.000Z","path":"2017/02/10/vue-cli-guide/","text":"一、文件结构本文主要分析开发（dev）和构建（build）两个过程涉及到的文件，故下面文件结构仅列出相应的内容。123456789101112131415161718├─build│ ├─build.js│ ├─check-versions.js│ ├─dev-client.js│ ├─dev-server.js│ ├─utils.js│ ├─vue-loader.conf.js│ ├─webpack.base.conf.js│ ├─webpack.dev.conf.js│ ├─webpack.prod.conf.js│ └─webpack.test.conf.js├─config│ ├─dev.env.js│ ├─index.js│ ├─prod.env.js│ └─test.env.js├─...└─package.json 二、指令分析首先看package.json里面的scripts字段，12345678\"scripts\": &#123; \"dev\": \"node build/dev-server.js\", \"build\": \"node build/build.js\", \"unit\": \"cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run\", \"e2e\": \"node test/e2e/runner.js\", \"test\": \"npm run unit &amp;&amp; npm run e2e\", \"lint\": \"eslint --ext .js,.vue src test/unit/specs test/e2e/specs\" &#125; 测试的东西先不看，直接看”dev”和”build”。运行”npm run dev”的时候执行的是build/dev-server.js文件，运行”npm run build”的时候执行的是build/build.js文件，我们可以从这两个文件开始进行代码阅读分析。 三、build文件夹分析build/dev-server.js首先来看执行”npm run dev”时候最先执行的build/dev-server.js文件。该文件主要完成下面几件事情： 检查node和npm的版本 引入相关插件和配置 创建express服务器和webpack编译器 配置开发中间件（webpack-dev-middleware）和热重载中间件（webpack-hot-middleware） 挂载代理服务和中间件 配置静态资源 启动服务器监听特定端口（8080） 自动打开浏览器并打开特定网址（localhost:8080）说明： express服务器提供静态文件服务，不过它还使用了http-proxy-middleware，一个http请求代理的中间件。前端开发过程中需要使用到后台的API的话，可以通过配置proxyTable来将相应的后台请求代理到专用的API服务器。 详情请看代码注释：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// 检查NodeJS和npm的版本require('./check-versions')()// 获取配置var config = require('../config')// 如果Node的环境变量中没有设置当前的环境（NODE_ENV），则使用config中的配置作为当前的环境if (!process.env.NODE_ENV) &#123; process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)&#125;// 一个可以调用默认软件打开网址、图片、文件等内容的插件// 这里用它来调用默认浏览器打开dev-server监听的端口，例如：localhost:8080var opn = require('opn')var path = require('path')var express = require('express')var webpack = require('webpack')// 一个express中间件，用于将http请求代理到其他服务器// 例：localhost:8080/api/xxx --&gt; localhost:3000/api/xxx// 这里使用该插件可以将前端开发中涉及到的请求代理到API服务器上，方便与服务器对接var proxyMiddleware = require('http-proxy-middleware')// 根据 Node 环境来引入相应的 webpack 配置var webpackConfig = process.env.NODE_ENV === 'testing' ? require('./webpack.prod.conf') : require('./webpack.dev.conf')// dev-server 监听的端口，默认为config.dev.port设置的端口，即8080var port = process.env.PORT || config.dev.port// 用于判断是否要自动打开浏览器的布尔变量，当配置文件中没有设置自动打开浏览器的时候其值为 falsevar autoOpenBrowser = !!config.dev.autoOpenBrowser// 定义 HTTP 代理表，代理到 API 服务器var proxyTable = config.dev.proxyTable// 创建1个 express 实例var app = express()// 根据webpack配置文件创建Compiler对象var compiler = webpack(webpackConfig)// webpack-dev-middleware使用compiler对象来对相应的文件进行编译和绑定// 编译绑定后将得到的产物存放在内存中而没有写进磁盘// 将这个中间件交给express使用之后即可访问这些编译后的产品文件var devMiddleware = require('webpack-dev-middleware')(compiler, &#123; publicPath: webpackConfig.output.publicPath, quiet: true&#125;)// webpack-hot-middleware，用于实现热重载功能的中间件var hotMiddleware = require('webpack-hot-middleware')(compiler, &#123; log: () =&gt; &#123;&#125;&#125;)// 当html-webpack-plugin提交之后通过热重载中间件发布重载动作使得页面重载compiler.plugin('compilation', function (compilation) &#123; compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) &#123; hotMiddleware.publish(&#123; action: 'reload' &#125;) cb() &#125;)&#125;)// 将 proxyTable 中的代理请求配置挂在到express服务器上Object.keys(proxyTable).forEach(function (context) &#123; var options = proxyTable[context] // 格式化options，例如将'www.example.com'变成&#123; target: 'www.example.com' &#125; if (typeof options === 'string') &#123; options = &#123; target: options &#125; &#125; app.use(proxyMiddleware(options.filter || context, options))&#125;)// handle fallback for HTML5 history API// 重定向不存在的URL，常用于SPAapp.use(require('connect-history-api-fallback')())// serve webpack bundle output// 使用webpack开发中间件// 即将webpack编译后输出到内存中的文件资源挂到express服务器上app.use(devMiddleware)// enable hot-reload and state-preserving// compilation error display// 将热重载中间件挂在到express服务器上app.use(hotMiddleware)// serve pure static assets// 静态资源的路径var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)// 将静态资源挂到express服务器上app.use(staticPath, express.static('./static'))// 应用的地址信息，例如：http://localhost:8080var uri = 'http://localhost:' + port// webpack开发中间件合法（valid）之后输出提示语到控制台，表明服务器已启动devMiddleware.waitUntilValid(function () &#123; console.log('&gt; Listening at ' + uri + '\\n')&#125;)// 启动express服务器并监听相应的端口（8080）module.exports = app.listen(port, function (err) &#123; if (err) &#123; console.log(err) return &#125; // when env is testing, don't need open it // 如果符合自动打开浏览器的条件，则通过opn插件调用系统默认浏览器打开对应的地址uri if (autoOpenBrowser &amp;&amp; process.env.NODE_ENV !== 'testing') &#123; opn(uri) &#125;&#125;) build/webpack.base.conf.js从代码中看到，dev-server使用的webpack配置来自build/webpack.dev.conf.js文件（测试环境下使用的是build/webpack.prod.conf.js，这里暂时不考虑测试环境）。而build/webpack.dev.conf.js中又引用了webpack.base.conf.js，所以这里我先分析webpack.base.conf.js。 webpack.base.conf.js主要完成了下面这些事情： 配置webpack编译入口 配置webpack输出路径和命名规则 配置模块resolve规则 配置不同类型模块的处理规则说明： 这个配置里面只配置了.js、.vue、图片、字体等几类文件的处理规则，如果需要处理其他文件可以在module.rules里面配置。 具体请看代码注释：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788var path = require('path')var utils = require('./utils')var config = require('../config')var vueLoaderConfig = require('./vue-loader.conf')// 给出正确的绝对路径function resolve (dir) &#123; return path.join(__dirname, '..', dir)&#125;module.exports = &#123; // 配置webpack编译入口 entry: &#123; app: './src/main.js' &#125;, // 配置webpack输出路径和命名规则 output: &#123; // webpack输出的目标文件夹路径（例如：/dist） path: config.build.assetsRoot, // webpack输出bundle文件命名格式 filename: '[name].js', // webpack编译输出的发布路径 publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;, // 配置模块resolve的规则 resolve: &#123; // 自动resolve的扩展名 extensions: ['.js', '.vue', '.json'], // resolve模块的时候要搜索的文件夹 modules: [ resolve('src'), resolve('node_modules') ], // 创建路径别名，有了别名之后引用模块更方便，例如 // import Vue from 'vue/dist/vue.common.js'可以写成 import Vue from 'vue' alias: &#123; 'vue$': 'vue/dist/vue.common.js', 'src': resolve('src'), 'assets': resolve('src/assets'), 'components': resolve('src/components') &#125; &#125;, // 配置不同类型模块的处理规则 module: &#123; rules: [ &#123;// 对src和test文件夹下的.js和.vue文件使用eslint-loader test: /\\.(js|vue)$/, loader: 'eslint-loader', enforce: \"pre\", include: [resolve('src'), resolve('test')], options: &#123; formatter: require('eslint-friendly-formatter') &#125; &#125;, &#123;// 对所有.vue文件使用vue-loader test: /\\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123;// 对src和test文件夹下的.js文件使用babel-loader test: /\\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test')] &#125;, &#123;// 对图片资源文件使用url-loader，query.name指明了输出的命名规则 test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', query: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123;// 对字体资源文件使用url-loader，query.name指明了输出的命名规则 test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: 'url-loader', query: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125;&#125; build/webpack.dev.conf.js接下来看webpack.dev.conf.js，这里面在webpack.base.conf的基础上增加完善了开发环境下面的配置，主要包括下面几件事情： 将hot-reload相关的代码添加到entry chunks 合并基础的webpack配置 使用styleLoaders 配置Source Maps 配置webpack插件 详情请看代码注释：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var utils = require('./utils')var webpack = require('webpack')var config = require('../config')// 一个可以合并数组和对象的插件var merge = require('webpack-merge')var baseWebpackConfig = require('./webpack.base.conf')// 一个用于生成HTML文件并自动注入依赖文件（link/script）的webpack插件var HtmlWebpackPlugin = require('html-webpack-plugin')// 用于更友好地输出webpack的警告、错误等信息var FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')// add hot-reload related code to entry chunksObject.keys(baseWebpackConfig.entry).forEach(function (name) &#123; baseWebpackConfig.entry[name] = ['./build/dev-client'].concat(baseWebpackConfig.entry[name])&#125;)// 合并基础的webpack配置module.exports = merge(baseWebpackConfig, &#123; // 配置样式文件的处理规则，使用styleLoaders module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap &#125;) &#125;, // 配置Source Maps。在开发中使用cheap-module-eval-source-map更快 devtool: '#cheap-module-eval-source-map', // 配置webpack插件 plugins: [ new webpack.DefinePlugin(&#123; 'process.env': config.dev.env &#125;), // https://github.com/glenjamin/webpack-hot-middleware#installation--usage new webpack.HotModuleReplacementPlugin(), // 后页面中的报错不会阻塞，但是会在编译结束后报错 new webpack.NoEmitOnErrorsPlugin(), // https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true &#125;), new FriendlyErrorsPlugin() ]&#125;) build/utils.js和build/vue-loader.conf.js前面的webpack配置文件中使用到了utils.js和vue-loader.conf.js这两个文件，utils主要完成下面3件事： 配置静态资源路径 生成cssLoaders用于加载.vue文件中的样式 生成styleLoaders用于加载不在.vue文件中的单独存在的样式文件vue-loader.conf则只配置了css加载器以及编译css之后自动添加前缀。详情请看代码注释（下面是vue-loader.conf的代码，utils代码里面原有的注释已经有相应说明这里就不贴出来了）：12345678910111213141516171819var utils = require('./utils')var config = require('../config')var isProduction = process.env.NODE_ENV === 'production'module.exports = &#123; // css加载器 loaders: utils.cssLoaders(&#123; sourceMap: isProduction ? config.build.productionSourceMap : config.dev.cssSourceMap, extract: isProduction &#125;), // 编译css之后自动添加前缀 postcss: [ require('autoprefixer')(&#123; browsers: ['last 2 versions'] &#125;) ]&#125; build/build.js讲完了开发环境下的配置，下面开始来看构建环境下的配置。执行”npm run build”的时候首先执行的是build/build.js文件，build.js主要完成下面几件事： loading动画 删除创建目标文件夹 webpack编译 输出信息说明： webpack编译之后会输出到配置里面指定的目标文件夹；删除目标文件夹之后再创建是为了去除旧的内容，以免产生不可预测的影响。 详情请看代码注释：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// https://github.com/shelljs/shelljs// 检查NodeJS和npm的版本require('./check-versions')()process.env.NODE_ENV = 'production'// Elegant terminal spinnervar ora = require('ora')var path = require('path')// 用于在控制台输出带颜色字体的插件var chalk = require('chalk')// 执行Unix命令行的插件var shell = require('shelljs')var webpack = require('webpack')var config = require('../config')var webpackConfig = require('./webpack.prod.conf')var spinner = ora('building for production...')spinner.start() // 开启loading动画// 输出文件的目标文件夹var assetsPath = path.join(config.build.assetsRoot, config.build.assetsSubDirectory)// 递归删除旧的目标文件夹shell.rm('-rf', assetsPath)// 重新创建文件夹 shell.mkdir('-p', assetsPath)shell.config.silent = true// 将static文件夹复制到输出的目标文件夹shell.cp('-R', 'static/*', assetsPath)shell.config.silent = false// webpack编译webpack(webpackConfig, function (err, stats) &#123; spinner.stop() // 停止loading动画 if (err) throw err // 没有出错则输出相关信息 process.stdout.write(stats.toString(&#123; colors: true, modules: false, children: false, chunks: false, chunkModules: false &#125;) + '\\n\\n') console.log(chalk.cyan(' Build complete.\\n')) console.log(chalk.yellow( ' Tip: built files are meant to be served over an HTTP server.\\n' + ' Opening index.html over file:// won\\'t work.\\n' ))&#125;) build/webpack.prod.conf.js构建的时候用到的webpack配置来自webpack.prod.conf.js，该配置同样是在webpack.base.conf基础上的进一步完善。主要完成下面几件事情： 合并基础的webpack配置 使用styleLoaders 配置webpack的输出 配置webpack插件 gzip模式下的webpack插件配置 webpack-bundle分析说明： webpack插件里面多了丑化压缩代码以及抽离css文件等插件。 详情请看代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180var path = require('path')var utils = require('./utils')var webpack = require('webpack')var config = require('../config')var merge = require('webpack-merge')var baseWebpackConfig = require('./webpack.base.conf')var HtmlWebpackPlugin = require('html-webpack-plugin')// 用于从webpack生成的bundle中提取文本到特定文件中的插件// 可以抽取出css，js文件将其与webpack输出的bundle分离var ExtractTextPlugin = require('extract-text-webpack-plugin')var env = process.env.NODE_ENV === 'testing' ? require('../config/test.env') : config.build.env// 合并基础的webpack配置var webpackConfig = merge(baseWebpackConfig, &#123; module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: true &#125;) &#125;, devtool: config.build.productionSourceMap ? '#source-map' : false, // 配置webpack的输出 output: &#123; // 编译输出目录 path: config.build.assetsRoot, // 编译输出文件名格式 filename: utils.assetsPath('js/[name].[chunkhash].js'), // 没有指定输出名的文件输出的文件名格式 chunkFilename: utils.assetsPath('js/[id].[chunkhash].js') &#125;, // 配置webpack插件 plugins: [ // http://vuejs.github.io/vue-loader/en/workflow/production.html new webpack.DefinePlugin(&#123; 'process.env': env &#125;), // 丑化压缩代码 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125;, sourceMap: true &#125;), // 抽离css文件 new ExtractTextPlugin(&#123; filename: utils.assetsPath('css/[name].[contenthash].css') &#125;), // generate dist index.html with correct asset hash for caching. // you can customize output by editing /index.html // see https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; filename: process.env.NODE_ENV === 'testing' ? 'index.html' : config.build.index, template: 'index.html', inject: true, minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true // more options: // https://github.com/kangax/html-minifier#options-quick-reference &#125;, // necessary to consistently work with multiple chunks via CommonsChunkPlugin chunksSortMode: 'dependency' &#125;), // split vendor js into its own file new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: function (module, count) &#123; // any required modules inside node_modules are extracted to vendor return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, '../node_modules') ) === 0 ) &#125; &#125;), // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest', chunks: ['vendor'] &#125;) ]&#125;)// gzip模式下需要引入compression插件进行压缩if (config.build.productionGzip) &#123; var CompressionWebpackPlugin = require('compression-webpack-plugin') webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp( '\\\\.(' + config.build.productionGzipExtensions.join('|') + ')$' ), threshold: 10240, minRatio: 0.8 &#125;) )&#125;if (config.build.bundleAnalyzerReport) &#123; var BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin())&#125;module.exports = webpackConfigbuild/check-versions.js和build/dev-client.js最后是build文件夹下面两个比较简单的文件，dev-client.js似乎没有使用到，代码也比较简单，这里不多讲。check-version.js完成对node和npm的版本检测，下面是其代码注释：// 用于在控制台输出带颜色字体的插件var chalk = require('chalk')// 语义化版本检查插件（The semantic version parser used by npm）var semver = require('semver')// 引入package.jsonvar packageConfig = require('../package.json')// 开辟子进程执行指令cmd并返回结果function exec (cmd) &#123; return require('child_process').execSync(cmd).toString().trim()&#125;// node和npm版本需求var versionRequirements = [ &#123; name: 'node', currentVersion: semver.clean(process.version), versionRequirement: packageConfig.engines.node &#125;, &#123; name: 'npm', currentVersion: exec('npm --version'), versionRequirement: packageConfig.engines.npm &#125;]module.exports = function () &#123; var warnings = [] // 依次判断版本是否符合要求 for (var i = 0; i &lt; versionRequirements.length; i++) &#123; var mod = versionRequirements[i] if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) &#123; warnings.push(mod.name + ': ' + chalk.red(mod.currentVersion) + ' should be ' + chalk.green(mod.versionRequirement) ) &#125; &#125; // 如果有警告则将其输出到控制台 if (warnings.length) &#123; console.log('') console.log(chalk.yellow('To use this template, you must update following to modules:')) console.log() for (var i = 0; i &lt; warnings.length; i++) &#123; var warning = warnings[i] console.log(' ' + warning) &#125; console.log() process.exit(1) &#125;&#125; 四、config文件夹分析config/index.jsconfig文件夹下最主要的文件就是index.js了，在这里面描述了开发和构建两种环境下的配置，前面的build文件夹下也有不少文件引用了index.js里面的配置。下面是代码注释：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// see http://vuejs-templates.github.io/webpack for documentation.var path = require('path')module.exports = &#123; // 构建产品时使用的配置 build: &#123; // webpack的编译环境 env: require('./prod.env'), // 编译输入的index.html文件 index: path.resolve(__dirname, '../dist/index.html'), // webpack输出的目标文件夹路径 assetsRoot: path.resolve(__dirname, '../dist'), // webpack编译输出的二级文件夹 assetsSubDirectory: 'static', // webpack编译输出的发布路径 assetsPublicPath: '/', // 使用SourceMap productionSourceMap: true, // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin // 默认不打开开启gzip模式 productionGzip: false, // gzip模式下需要压缩的文件的扩展名 productionGzipExtensions: ['js', 'css'], // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off bundleAnalyzerReport: process.env.npm_config_report &#125;, // 开发过程中使用的配置 dev: &#123; // webpack的编译环境 env: require('./dev.env'), // dev-server监听的端口 port: 8080, // 启动dev-server之后自动打开浏览器 autoOpenBrowser: true, // webpack编译输出的二级文件夹 assetsSubDirectory: 'static', // webpack编译输出的发布路径 assetsPublicPath: '/', // 请求代理表，在这里可以配置特定的请求代理到对应的API接口 // 例如将'/api/xxx'代理到'www.example.com/api/xxx' proxyTable: &#123;&#125;, // CSS Sourcemaps off by default because relative paths are \"buggy\" // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. // 是否开启 cssSourceMap cssSourceMap: false &#125;&#125; config/dev.env.js、config/prod.env.js和config/test.env.js这三个文件就简单设置了环境变量而已，没什么特别的。 五、总结到这里对模板项目的build和config文件夹下面的内容已经基本了解，知道了在实际使用中根据自己的需求修改哪里的配置，例如，当我有需要配置代理的时候要在config/index.js里面的dev.proxyTable设置，当我修改了资源文件夹名称static同样需要在config/index.js里面设置。总体感觉入门了webpack，但不算真正理解。webpack的插件好多，在看代码的过程中遇到不认识的插件都是要去查看很多文档（github，npm或者博客），感觉实际过程中更改插件配置或者使用新插件也是需要费点心思钻文档和网上其他博客介绍。 转自http://www.qdfuns.com/notes/40585/9e2cd48b5ef2c1fc14118eabe67d11bc.html","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"微信小程序的一次实践","date":"2017-01-11T14:14:00.000Z","path":"2017/01/11/wxapp/","text":"微信宣布小程序开放内测第二天，公司运营拿到内测资格，欣喜若癫，誓要拿下微信给的这第一波红利。当即随着微信开始了踩坑之旅。 代码结构：123456789101112131415161718192021222324252627282930wxapp│ app.js 主程序入口│ app.json 配置│ app.wxss 全局样式│ config.js 环境变量配置│ configureStore.js 创建store├─actions │ index.js├─pages 各业务页面存放目录│ ├─index│ │ index.js│ │ index.json│ │ index.wxml│ │ index.wxss│ ~... ├─public 公共资源：图片，组件│ ├─image│ └─components │ ├─toast│ │ toast.js│ │ toast.wxml│ ~... ├─reducers │ index.js│ └─utils 公共函数 mta_analysis.js promise.js redux.js util.js 最终代码结构如上；由于引入了redux，所以多了actions和reducers两个目录，至于为什么要大费周章在小程序中使用redux曾经有人说过这样一句话： “如果你不知道是否需要 Redux，那就是不需要它。” Redux 的创造者 Dan Abramov 又补充了一句： “只有遇到 React 实在解决不了的问题，你才需要 Redux 。” 我就是要用，你管我！？ 遇到过的问题 遇到的第一个就是跨域的问题：之前的业务逻辑依赖于用户session，在小程序中每次请求所带的sessionid都是新的，不能维持登录态。还有开发阶段在外网服务器没有对应api，并且wx.request强制检查域名的问题。解决方法：加入config.js：配置环境变量；并且添加_ajax函数，把wx.request多封一层，在开发阶段使用XMLHttpRequest原生对象（在当时还可以，之后开发可以选择不验证域名，并且屏蔽了这个对象）在每次发送的data中添加userid段，内容为服务器返回的用户标识。 组件仅仅是视图模板可重用，并非组件可重用：WXML语法中支持import和 include，在小程序开发中，只能将列表的模板抽象出来，不能将逻辑抽象出来，所以你就需要在两个页面上都实现一遍列表组件的控制逻辑，比如刷新、加载更多。。。 wx.component不符合自己公司对于样式的需求，所以public下多了components目录，使用的时候要在wxml和js中分别引入。 在首次初始化时，缓存中无用户标识，每次发起请求时无标示要先请求授权，在回调函数中执行自己的逻辑。初始化时发起多个请求，异步的原因，需要用户多次确认授权，造成很差的体验。解决方法：在app.js中全局添加一个单例promise对象，在还未得到服务器返回标识时，将所有请求推入等候队列，等得到后再执行。 成品生成K米点歌小程序二维码","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"wxapp","slug":"wxapp","permalink":"http://yoursite.com/tags/wxapp/"}]},{"title":"promise简单实现","date":"2017-01-10T11:30:00.000Z","path":"2017/01/10/promise/","text":"概念ES6 原生提供了 Promise 对象。所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。Promise 对象有以下两个特点。 （1）对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 用法在写微信小程序的时候，有时需要等第一个异步请求返回内容之后再开始第二个异步请求，然后再做逻辑处理，受够了层层嵌套的回调,决心换一个直观的写法。 原写法：1234567891011121314151617$.ajax(&#123; method:'', data:'', success:function() &#123; $.ajax(&#123; success:function() &#123; //Do something &#125;, error:function() &#123; alert('err') &#125; &#125;) &#125;, error:function() &#123; alert('err') &#125;&#125;) 用了promise之后：123456789101112131415161718192021var a = new Promise(function(resolve,reject)&#123; $.ajax(&#123; success:function(data) &#123; resolve(data) &#125;, error:function(e) &#123; reject(e) &#125; &#125;)&#125;)var b = new Promise(function(resolve,reject)&#123; $.ajax(&#123; success:function(data) &#123; resolve(data) &#125;, error:function(e) &#123; reject(e) &#125; &#125;) &#125;)a().then(function(data)&#123;console.log(data);return b&#125;).then(data=&gt;console.log(data)); ##简单实现： 语法是es6，后面是经过babel编译的代码，不熟悉es6的同学不太影响阅读。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Promise&#123; constructor(fn)&#123; this.state = 'pending'; this.value = null; this.deferreds = []; this._resolve = this.resolve.bind(this) this._reject = this.reject.bind(this) fn(this._resolve,this._reject) &#125; handle(deferred) &#123; if (this.state === 'pending') &#123; this.deferreds.push(deferred); return; &#125; var cb = this.state === 'fulfilled' ? deferred.onFulfilled : deferred.onRejected, ret; if (cb === null) &#123; cb = this.state === 'fulfilled' ? deferred.resolve : deferred.reject; cb(this.value); return; &#125; try &#123; ret = cb(this.value); deferred.resolve(ret); &#125; catch (e) &#123; deferred.reject(e); &#125; &#125; resolve(newValue) &#123; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then; if (typeof then === 'function') &#123; then.call(newValue, this.resolve, this.reject); return; &#125; &#125; this.state = 'fulfilled'; this.value = newValue; this.finale(); &#125; reject(reason) &#123; this.state = 'rejected'; this.value = reason; this.finale(); &#125; finale() &#123; setTimeout(function () &#123; this.deferreds.forEach(function (deferred) &#123; this.handle(deferred); &#125;.bind(this)); &#125;.bind(this), 0); &#125; then(onFulfilled, onRejected)&#123; return new Promise(function (resolve, reject) &#123; this.handle(&#123; onFulfilled: onFulfilled || null, onRejected: onRejected || null, resolve: resolve, reject: reject &#125;); &#125;.bind(this)); &#125;&#125;//测试var a = new Promise(function(res,rej)&#123; setTimeout(function()&#123; let a = 1; let b = 2; if(1)&#123; res(a) &#125;else&#123; rej(b) &#125; &#125;,2000)&#125;);var b = new Promise(function(res,rej)&#123; setTimeout(function()&#123; let c = 3; let d = 4; if(1)&#123; res(c) &#125;else&#123; rej(d) &#125; &#125;,2000)&#125;);a.then(y=&gt;console.log(y), n=&gt;console.log(n) ).then(()=&gt;&#123;return b&#125;).then(y=&gt;console.log(y)) 编译之后；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126'use strict';var _createClass = (function () &#123; function defineProperties(target, props) &#123; for (var i = 0; i &lt; props.length; i++) &#123; var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); &#125; &#125; return function (Constructor, protoProps, staticProps) &#123; if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; &#125;; &#125;)();function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError('Cannot call a class as a function'); &#125; &#125;var Promise = (function () &#123; function Promise(fn) &#123; _classCallCheck(this, Promise); this.state = 'pending'; this.value = null; this.deferreds = []; this.resolve = this.resolve.bind(this); this.reject = this.reject.bind(this); fn(this.resolve, this.reject); &#125; _createClass(Promise, [&#123; key: 'handle', value: function handle(deferred) &#123; if (this.state === 'pending') &#123; this.deferreds.push(deferred); return; &#125; var cb = this.state === 'fulfilled' ? deferred.onFulfilled : deferred.onRejected, ret; if (cb === null) &#123; cb = this.state === 'fulfilled' ? deferred.resolve : deferred.reject; cb(this.value); return; &#125; try &#123; ret = cb(this.value); deferred.resolve(ret); &#125; catch (e) &#123; deferred.reject(e); &#125; &#125; &#125;, &#123; key: 'resolve', value: function resolve(newValue) &#123; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then; if (typeof then === 'function') &#123; then.call(newValue, this.resolve, this.reject); return; &#125; &#125; this.state = 'fulfilled'; this.value = newValue; this.finale(); &#125; &#125;, &#123; key: 'reject', value: function reject(reason) &#123; this.state = 'rejected'; this.value = reason; this.finale(); &#125; &#125;, &#123; key: 'finale', value: function finale() &#123; setTimeout((function () &#123; console.log(this); this.deferreds.forEach((function (deferred) &#123; this.handle(deferred); &#125;).bind(this)); &#125;).bind(this), 0); &#125; &#125;, &#123; key: 'then', value: function then(onFulfilled, onRejected) &#123; return new Promise((function (resolve, reject) &#123; this.handle(&#123; onFulfilled: onFulfilled || null, onRejected: onRejected || null, resolve: resolve, reject: reject &#125;); &#125;).bind(this)); &#125; &#125;]); return Promise;&#125;)();var a = new Promise(function (res, rej) &#123; setTimeout(function () &#123; var a = 1; var b = 2; if (1) &#123; res(a); &#125; else &#123; rej(b); &#125; &#125;, 2000);&#125;);var b = new Promise(function (res, rej) &#123; setTimeout(function () &#123; var c = 3; var d = 4; if (1) &#123; res(c); &#125; else &#123; rej(d); &#125; &#125;, 2000);&#125;);a.then(function (y) &#123; return console.log(y);&#125;, function (n) &#123; return console.log(n);&#125;).then(function () &#123; return b;&#125;).then(function (y) &#123; return console.log(y);&#125;);","tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"我的学习路","date":"2016-12-29T13:25:00.000Z","path":"2016/12/29/learn/","text":"一点人生的经验: 2016读过的书2016读过的书,从一个拍黄片（php）的学着学着学到前端。。。 总结一下，外加一下觉得必须要学的知识。 使用Chrome DevTools的Timeline分析页面性能 前端基础进阶系列一系列能够把JS的一些概念理解透彻，并且梳理的清楚的文章。认真看完获益匪浅，不禁想责怪作者为什么这么迟才把文章写出来。文章依然在更新，期待中。ECMAScript 6 入门在学习如react、vue等前端框架之前应该对ES6有了解。虽然项目中不一定会用到ES6的语法，但是有助于理解别人写的项目。（你懂的） 《一起学 Node.js》node开发环境搭建就靠它。 阮一峰博客里面关于react技术栈的文章写的非常详细，最适合新手入门。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"记一次写jQuery插件","date":"2016-05-18T08:33:00.000Z","path":"2016/05/18/jquery-extend/","text":"一款js插件应该满足以下8个要求： 代码相对独立 链式操作 插件可配置 有可操作的方法，插件的生命周期可控制 配置可被缓存 可扩展 无冲突处理 事件代理，动态初始化 以往我们写插件的方式如下：123456function pluginName($selector)&#123; $.each($selector, function () &#123; // to do something... &#125;);&#125;// pluginName(document.getElementsByClassName(\"demo\")); 现把代码扩展到jQuery上12345678910111213141516;(function ($) &#123; // 扩展这个方法到jQuery. $.fn.extend(&#123; // 插件名字 pluginName: function () &#123; // 遍历匹配元素的集合 // 注意这里有个\"return\"，作用是把处理后的对象返回，实现链式操作 return this.each(function () &#123; // 在这里编写相应的代码进行处理 &#125;); &#125; &#125;);// 传递jQuery到内层作用域去, 如果window,document用的多的话, 也可以在这里传进去.// &#125;)(jQuery, window, document, undefined);&#125;)(jQuery, undefined);// 调用方式 $(\".selector\").pluginName().otherMethod(); 至此解决了 代码相对独立 链式操作这2个问题，接下来给插件添加参数支持123456789101112131415;(function($)&#123; $.fn.pluginName = function(options) &#123; // 合并参数，通过“extend”合并默认参数和自定义参数 var args = $.extend(&#123;&#125;, $.fn.pluginName.defaults, options); return this.each(function() &#123; console.log(args.text); // to do something... &#125;); &#125;; // 默认参数 $.fn.pluginName.defaults = &#123; text : \"hello\" &#125;;&#125;)(jQuery);// $(\".selector\").pluginName(&#123;text : \"hello world!\"&#125;); 现在来添加方法的支持，我前面所提到的生命周期可控制，意思差不多，例如添加reInit,destory等方法来控制插件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344;(function($)&#123; $.fn.pluginName = function (method) &#123; // 如果第一个参数是字符串, 就查找是否存在该方法, 找到就调用; 如果是object对象, 就调用init方法;. if (methods[method]) &#123; // 如果存在该方法就调用该方法 // apply 是吧 obj.method(arg1, arg2, arg3) 转换成 method(obj, [arg1, arg2, arg3]) 的过程. // Array.prototype.slice.call(arguments, 1) 是把方法的参数转换成数组. return methods[method].apply(this, Array.prototype.slice.call(arguments, 1)); &#125; else if (typeof method === 'object' || !method) &#123; // 如果传进来的参数是\"&#123;...&#125;\", 就认为是初始化操作. return methods.init.apply(this, arguments); &#125; else &#123; $.error('Method ' + method + ' does not exist on jQuery.pluginName'); &#125; &#125;; // 不把方法扩展在 $.fn.pluginName 上. 在闭包内建个\"methods\"来保存方法, 类似共有方法. var methods = &#123; /** * 初始化方法 * @param _options * @return &#123;*&#125; */ init : function (_options) &#123; return this.each(function () &#123; var $this = $(this); var args = $.extend(&#123;&#125;, $.fn.pluginName.defaults, _options); // ... &#125;) &#125;, publicMethod : function()&#123; private_methods.demoMethod(); &#125; &#125;; // 私有方法 var private_methods = &#123; demoMethod : function()&#123;&#125; &#125; // 默认参数 $.fn.pluginName.defaults = &#123; &#125;;&#125;)(jQuery);// 调用方式// $(\"div\").pluginName(&#123;...&#125;); // 初始化// $(\"div\").pluginName(\"publicMethod\"); // 调用方法 至此已经能满足大部分插件需求。 代码相对独立 链式操作 插件可配置 有可操作的方法，插件的生命周期可控制剩下的继续升级： 1234567891011121314151617181920212223242526272829303132;(function ($) &#123; var Plugin = function (element, options) &#123; this.element = element; this.options = options; &#125;; Plugin.prototype = &#123; create: function () &#123; console.log(this.element); console.log(this.options); &#125; &#125;; $.fn.pluginName = function (options) &#123; // 合并参数 return this.each(function () &#123; // 在这里编写相应的代码进行处理 var ui = $._data(this, \"pluginName\"); // 如果该元素没有初始化过(可能是新添加的元素), 就初始化它. if (!ui) &#123; var opts = $.extend(true, &#123;&#125;, $.fn.pluginName.defaults, typeof options === \"object\" ? options : &#123;&#125;); ui = new Plugin(this, opts); // 缓存插件 $._data(this, \"pluginName\", ui); &#125; // 调用方法 if (typeof options === \"string\" &amp;&amp; typeof ui[options] == \"function\") &#123; // 执行插件的方法 ui[options].apply(ui, args); &#125; &#125;); &#125;; $.fn.pluginName.defaults = &#123;&#125;;&#125;)(jQuery); var ui = $._data(this, &quot;pluginName&quot;);这里画重点；把初始化后的插件缓存起来后，方便了许多。通过代码$(“#target”).data(“pluginName”)就可以取到对象了实现了 配置可缓存 最后最后，解决剩下的三个要求 可扩展 无冲突处理 事件代理，动态初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849!function ($) &#123; \"use strict\"; var Button = function (element, options) &#123; this.$element = $(element); this.options = $.extend(&#123;&#125;, Button.DEFAULTS, options); &#125;; Button.DEFAULTS = &#123; loadingText: 'loading...' &#125;; Button.prototype.setState = function (state) &#123; // ... &#125;; Button.prototype.toggle = function () &#123; // ... &#125;; var old = $.fn.button; // 这里的 $.fn.button 有可能是之前已经有定义过的插件，在这里做无冲突处理使用。 $.fn.button = function (option) &#123; return this.each(function () &#123; var $this = $(this); // 判断是否初始化过的依据 var data = $this.data('bs.button'); var options = typeof option == 'object' &amp;&amp; option; // 如果没有初始化过, 就初始化它 if (!data) $this.data('bs.button', (data = new Button(this, options))); if (option == 'toggle') data.toggle(); else if (option) data.setState(option) &#125;) &#125;; // ① 暴露类名, 可以通过这个为插件做自定义扩展 $.fn.button.Constructor = Button; // 扩展的方式 // 设置 : $.fn.button.Constructor.newMethod = function()&#123;&#125; // 使用 : $btn.button(\"newMethod\"); // ② 无冲突处理 $.fn.button.noConflict = function () &#123; $.fn.button = old; return this &#125;; // ③ 事件代理, 智能初始化 $(document).on('click.bs.button.data-api', '[data-toggle^=button]', function (e) &#123; var $btn = $(e.target); // 查找要初始化的对象 if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn'); // 直接调用方法, 如果没有初始化, 内部会先进行初始化 $btn.button('toggle'); e.preventDefault(); &#125;);&#125;(jQuery); 补充现在的插件都要求灵活性要高，比如希望插件可以同时适配jQuery和Zepto，又或者需要支持AMD或者CMD规范。支持jQuery和Zepto复制代码 代码如下:12345if (window.jQuery || window.Zepto) &#123; (function ($) &#123; // plugin code... &#125;)(window.jQuery || window.Zepto);&#125; 中间件支持，node复制代码 代码如下:12345678910111213141516171819if (typeof(module) !== 'undefined')&#123; module.exports = pluginName;&#125;//requirejs(AMD) supportif (typeof define === 'function' &amp;&amp; define.amd) &#123; define([], function () &#123; 'use strict'; return pluginName; &#125;);&#125;//seajs(CMD) supportif (typeof define === 'function') &#123; define([], function () &#123; 'use strict'; return pluginName; &#125;);&#125;` 实际：看了这么多，下面是一个H5上传插件的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347(function ($) &#123; \"use strict\"; var Plugin = function (element, options) &#123; this.element = element; this.options = options; &#125;; Plugin.prototype = &#123; destroy: function () &#123; $(this.element).empty(); this.options.onDestroy &amp;&amp; this.options.onDestroy() &#125;, init: function () &#123; &#125;, settings: function () &#123; var newOpt = &#123;&#125;; newOpt[arguments[0][1]] = arguments[0][2]; $.extend(this.options, newOpt); this.destroy(); $(this.element).Uploadify(this.options); &#125; &#125;; $.fn.Uploadify = function (opts) &#123; var _this = $(this), arg = arguments; var itemTemp = ''; $.fn.Uploadify.defaults = &#123; fileTypeExts: '',//允许上传的文件类型，格式'*.jpg;*.doc' uploader: '',//文件提交的地址 auto: false,//是否开启自动上传 method: 'post',//发送请求的方式，get或post multi: true,//是否允许选择多个文件 formData: null,//发送给服务端的参数，格式：&#123;key1:value1,key2:value2&#125; fileObjName: 'file',//在后端接受文件的参数名称，如PHP中的$_FILES['file'] fileSizeLimit: 2048,//允许上传的文件大小，单位KB showUploadedPercent: false,//是否实时显示上传的百分比，如20% showUploadedSize: false,//是否实时显示已上传的文件大小，如1M/2M buttonText: '选择文件',//上传按钮上的文字 removeTimeout: 1000,//上传完成后进度条的消失时间 itemTemplate: itemTemp,//上传队列显示的模板 onUploadStart: null,//上传开始时的动作 onUploadSuccess: null,//上传成功的动作 onUploadComplete: null,//上传完成的动作 onUploadError: null, //上传失败的动作 onInit: null,//初始化时的动作 onCancel: null,//删除掉某个文件后的回调函数，可传入参数file queueID: '.uploadify-queue',//默认显示文件队列的div showImg: true, removeCompleted: false, uploadLimit: false, onDestory: null, showUpdateAll: true//显示全部上传按钮 &#125; // var option = $.extend(&#123;&#125;,$.fn.Uploadify.defaults,opts); var a; if (typeof opts == 'string') &#123; a = opts &#125; else &#123; a = $.extend(true, &#123;&#125;, $.fn.Uploadify.defaults, typeof opts === \"object\" ? opts : &#123;&#125;); &#125; //将文件的单位由bytes转换为KB或MB，若第二个参数指定为true，则永远转换为KB var formatFileSize = function (size, byKB) &#123; if (size &gt; 1024 * 1024 &amp;&amp; !byKB) &#123; size = (Math.round(size * 100 / (1024 * 1024)) / 100).toString() + 'MB'; &#125; else &#123; size = (Math.round(size * 100 / 1024) / 100).toString() + 'KB'; &#125; return size; &#125; //根据文件序号获取文件 var getFile = function (index, files) &#123; for (var i = 0; i &lt; files.length; i++) &#123; if (files[i].index == index) &#123; return files[i]; &#125; &#125; return false; &#125; //将输入的文件类型字符串转化为数组,原格式为*.jpg;*.png var getFileTypes = function (str) &#123; var result = []; var arr1 = str.split(\";\"); for (var i = 0, len = arr1.length; i &lt; len; i++) &#123; result.push(arr1[i].split(\".\").pop()); &#125; return result; &#125; var options = a; return this.each(function () &#123; var ui = $._data(this, \"Uploadify\"); if (!ui) &#123; ui = new Plugin(this, options); // 缓存插件 $._data(this, \"Uploadify\", ui); &#125; // 调用方法 if (typeof options === \"string\" &amp;&amp; typeof ui[options] == \"function\") &#123; // 执行插件的方法 ui[options].call(ui, arg); return &#125; var _this = $(ui.element); //先添加上file按钮和上传列表 var instanceNumber = $('.uploadify').length + 1; var inputStr = '&lt;input class=\"selectbtn\" style=\"display:none;\" type=\"file\" name=\"fileselect[]\"'; inputStr += ui.options.multi ? ' multiple' : ''; inputStr += ' accept=\"'; inputStr += getFileTypes(ui.options.fileTypeExts).join(\",\"); inputStr += '\"/&gt;'; inputStr += '&lt;button type=\"button\" class=\"uploadify-button style-uploadify-button btn-primary margin-10\"&gt;'; inputStr += ui.options.buttonText; inputStr += '&lt;/button&gt;'; if (options.showUpdateAll &amp;&amp; (options.uploadLimit &gt; 1 || options.uploadLimit === false)) &#123; inputStr += '&lt;button type=\"button\" class=\"uploadify-all style-uploadify-button btn-primary margin-10\"&gt;'; inputStr += '全部上传'; inputStr += '&lt;/button&gt;'; &#125; var uploadFileListStr = '&lt;div class=\"uploadify-queue\"&gt;&lt;/div&gt;'; _this.append(inputStr + uploadFileListStr); //创建文件对象 var fileObj = &#123; fileInput: _this.find('.selectbtn'), //html file控件 uploadFileList: _this.find('.uploadify-queue'), url: ui.options.uploader, //ajax地址 fileFilter: [], //过滤后的文件数组 arrLastModified: [], //保存已上传过的文件数组 filter: function (files) &#123; //选择文件组的过滤方法 var arr = []; var typeArray = getFileTypes(ui.options.fileTypeExts); var fileCount = files.length; if (ui.options.uploadLimit !== false) &#123; if (fileCount &gt; ui.options.uploadLimit || (fileCount + this.fileFilter.length) &gt; ui.options.uploadLimit) &#123; alert('超过文件个数限制,请重新选择文件'); return arr; &#125; &#125; if (typeArray.length &gt; 0) &#123; for (var i = 0, len = files.length; i &lt; len; i++) &#123; var hasInputed = false; var thisFile = files[i]; if (parseInt(formatFileSize(thisFile.size, true)) &gt; ui.options.fileSizeLimit) &#123; alert('文件' + thisFile.name + '大小超出限制！'); continue; &#125; if ($.inArray(thisFile.name.split('.').pop(), typeArray) &gt;= 0) &#123; for (var j = 0; j &lt; this.fileFilter.length; j++) &#123; var fileFilter = this.fileFilter[j]; if (thisFile.lastModified + thisFile.name == fileFilter.lastModified + fileFilter.name) &#123; hasInputed = true; break; &#125; &#125; if (!hasInputed) arr.push(thisFile); &#125; else &#123; alert('文件' + thisFile.name + '类型不允许！'); &#125; &#125; &#125; return arr; &#125;, //文件选择后 onSelect: function (files) &#123; for (var i = 0, len = files.length; i &lt; len; i++) &#123; var file = files[i]; //处理模板中使用的变量 var $html = $(ui.options.itemTemplate.replace(/\\$&#123;fileID&#125;/g, 'fileupload_' + instanceNumber + '_' + file.index).replace(/\\$&#123;fileName&#125;/g, file.name).replace(/\\$&#123;fileSize&#125;/g, formatFileSize(file.size)).replace(/\\$&#123;instanceID&#125;/g, _this.attr('id'))); file.id = 'fileupload_' + instanceNumber + '_' + file.index; //如果是自动上传，去掉上传按钮 if (ui.options.auto) &#123; $html.find('.uploadbtn').remove(); $html.find('.delfilebtn').remove(); &#125; this.uploadFileList.append($html); //判断是否显示已上传文件大小 if (ui.options.showUploadedSize) &#123; var num = '&lt;span class=\"progressnum\"&gt;&lt;span class=\"uploadedsize\"&gt;0KB&lt;/span&gt;/&lt;span class=\"totalsize\"&gt;$&#123;fileSize&#125;&lt;/span&gt;&lt;/span&gt;'.replace(/\\$&#123;fileSize&#125;/g, formatFileSize(file.size)); $html.find('.uploadify-progress').after(num); &#125; //判断是否显示上传百分比 if (ui.options.showUploadedPercent) &#123; var percentText = '&lt;span class=\"up_percent\"&gt;0%&lt;/span&gt;'; $html.find('.uploadify-progress').after(percentText); &#125; //判断是否是自动上传 if (ui.options.auto) &#123; this.funUploadFile(file); &#125; else &#123; //如果配置非自动上传，绑定上传事件 $html.find('.uploadbtn').on('click', (function (file) &#123; return function () &#123; fileObj.funUploadFile(file); &#125; &#125;)(file)); &#125; //为删除文件按钮绑定删除文件事件 $html.find('.delfilebtn').on('click', (function (file, callback) &#123; // $elm = $html.find('.delfilebtn'); // // typeof callback == 'function' &amp;&amp; callback(file,$elm); return function () &#123; fileObj.funDeleteFile(file.index); &#125; &#125;)(file, ui.options.ondelate)); this.showImg(file, 'fileupload_' + instanceNumber + '_' + file.index); &#125; _this.find('.uploadify-all').unbind().on('click', function () &#123; for (var i = 0, len = fileObj.fileFilter.length; i &lt; len; i++) &#123; var file = fileObj.fileFilter[i]; fileObj.funUploadFile(file); &#125; &#125;); &#125;, onProgress: function (file, loaded, total) &#123; var eleProgress = _this.find('#fileupload_' + instanceNumber + '_' + file.index + ' .uploadify-progress'); var percent = ((loaded / total * 100) - 1).toFixed(2) + '%'; if (ui.options.showUploadedSize) &#123; eleProgress.nextAll('.progressnum .uploadedsize').text(formatFileSize(loaded)); eleProgress.nextAll('.progressnum .totalsize').text(formatFileSize(total)); &#125; if (ui.options.showUploadedPercent) &#123; eleProgress.nextAll('.up_percent').text(percent); &#125; eleProgress.children('.uploadify-progress-bar').css('width', percent); &#125;, //文件上传进度 /* 开发参数和内置方法分界线 */ //获取选择文件，file控件 showImg: function (file, elm) &#123; var src = window.URL.createObjectURL(file); _this.find(ui.options.queueID).find('#' + elm).prepend('&lt;img class=\"showimgtag\" src=\"' + src + '\"&gt;') &#125;, funGetFiles: function (e) &#123; // 获取文件列表对象 var files = e.target.files; //继续添加文件 files = this.filter(files); for (var i = 0, len = files.length; i &lt; len; i++) &#123; this.fileFilter.push(files[i]); &#125; this.funDealFiles(files); return this; &#125;, //选中文件的处理与回调 funDealFiles: function (files) &#123; var fileCount = _this.find('.uploadify-queue .uploadify-queue-item').length;//队列中已经有的文件个数 for (var i = 0, len = files.length; i &lt; len; i++) &#123; files[i].index = ++fileCount; files[i].id = files[i].index; &#125; //执行选择回调 this.onSelect(files); return this; &#125;, //删除对应的文件 funDeleteFile: function (index) &#123; for (var i = 0, len = this.fileFilter.length; i &lt; len; i++) &#123; var file = this.fileFilter[i]; if (file.index == index) &#123; this.fileFilter.splice(i, 1); _this.find('#fileupload_' + instanceNumber + '_' + index).fadeOut(); var lastModified = file.lastModified + file.name; for (var j = 0; j &lt; fileObj.arrLastModified.length; j++) &#123; if (fileObj.arrLastModified[j] === lastModified) &#123; fileObj.arrLastModified.splice(j, 1); &#125; &#125; ui.options.onCancel &amp;&amp; ui.options.onCancel(file); break; &#125; &#125; return this; &#125;, //文件上传 funUploadFile: function (file) &#123; var xhr = false; try &#123; xhr = new XMLHttpRequest();//尝试创建 XMLHttpRequest 对象，除 IE 外的浏览器都支持这个方法。 &#125; catch (e) &#123; xhr = ActiveXobject(\"Msxml12.XMLHTTP\");//使用较新版本的 IE 创建 IE 兼容的对象（Msxml2.XMLHTTP）。 &#125; if (xhr.upload) &#123; if ($.inArray(file.lastModified + file.name, fileObj.arrLastModified) != -1) return; // 上传中 xhr.upload.addEventListener(\"progress\", function (e) &#123; fileObj.onProgress(file, e.loaded, e.total); &#125;, false); // 文件上传成功或是失败 xhr.onreadystatechange = function (e) &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; //校正进度条和上传比例的误差 var thisfile = _this.find('#fileupload_' + instanceNumber + '_' + file.index); thisfile.find('.uploadify-progress-bar').css('width', '100%'); ui.options.showUploadedSize &amp;&amp; thisfile.find('.uploadedsize').text(thisfile.find('.totalsize').text()); ui.options.showUploadedPercent &amp;&amp; thisfile.find('.up_percent').text('100%'); // _this.find('.uploadbtn').attr('disabled','disabled') ui.options.onUploadSuccess &amp;&amp; ui.options.onUploadSuccess(file, xhr.responseText); //在指定的间隔时间后删掉进度条 if (ui.options.removeCompleted &amp;&amp; ui.options.removeTimeout &gt; 0) &#123; setTimeout(function () &#123; _this.find('#fileupload_' + instanceNumber + '_' + file.index).fadeOut(); &#125;, ui.options.removeTimeout); &#125; &#125; else &#123; ui.options.onUploadError &amp;&amp; ui.options.onUploadError(file, xhr.responseText, fileObj.funUploadFile); &#125; ui.options.onUploadComplete &amp;&amp; ui.options.onUploadComplete(file, xhr.responseText); //清除文件选择框中的已有值 fileObj.arrLastModified.push(file.lastModified + file.name); fileObj.fileInput.val(''); &#125; &#125;; ui.options.onUploadStart &amp;&amp; ui.options.onUploadStart(); // 开始上传 xhr.open(ui.options.method, this.url, true); xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"); var fd = new FormData(); fd.append(ui.options.fileObjName, file); if (ui.options.formData) &#123; for (var key in ui.options.formData) &#123; fd.append(key, ui.options.formData[key]); &#125; &#125; xhr.send(fd); &#125; &#125;, init: function () &#123; //文件选择控件选择 if (this.fileInput.length &gt; 0) &#123; this.fileInput.change(function (e) &#123; fileObj.funGetFiles(e); $(this).val(''); &#125;); &#125; //点击上传按钮时触发file的click事件 _this.find('.uploadify-button').on('click', function () &#123; _this.find('.selectbtn').trigger('click'); &#125;); ui.options.onInit &amp;&amp; ui.options.onInit(); &#125; &#125;; //初始化文件对象 fileObj.init(); &#125;); &#125;&#125;)(jQuery)","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Hello world","date":"2015-10-21T13:25:00.000Z","path":"2015/10/21/hellow-world/","text":"技术向，不搞笑。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]